#include "stir/IO/HDF5Wrapper.h"
#include <sstream>

START_NAMESPACE_STIR

bool HDF5Wrapper::check_GE_signature(const std::string filename)
{
    H5::H5File file;

    if(!file.isHdf5(filename))
        return false;

    file.openFile( filename, H5F_ACC_RDONLY );
    H5::StrType  vlst(0,37);  // 37 here is the length of the string (I got it from the text file generated by list2txt with the LIST000_decomp.BLF

    std::string read_str_scanner;
    std::string read_str_manufacturer;

    H5::DataSet dataset = file.openDataSet("/HeaderData/ExamData/scannerDesc");
    dataset.read(read_str_scanner,vlst);

    H5::DataSet dataset2= file.openDataSet("/HeaderData/ExamData/manufacturer");
    dataset2.read(read_str_manufacturer,vlst);

    if(read_str_scanner == "SIGNA PET/MR" &&
            read_str_manufacturer == "GE MEDICAL SYSTEMS")
        return true;

    return false;
}

HDF5Wrapper::HDF5Wrapper()
{

}

HDF5Wrapper::HDF5Wrapper(const std::string& filename)
{
    open(filename);

}

shared_ptr<Scanner>
HDF5Wrapper::get_scanner_sptr() const
{
    return this->scanner_sptr;
}

shared_ptr<ExamInfo>
HDF5Wrapper::get_exam_info_sptr() const
{
    return this->exam_info_sptr;
}

H5::DataSet* HDF5Wrapper::get_dataset_ptr() const
{
    return m_dataset_sptr.get();
}

hsize_t HDF5Wrapper::get_dataset_size() const
{
    return m_list_size;
}

TimeFrameDefinitions* HDF5Wrapper::get_timefreme_definitions() const
{
    //! \todo For examInfo get timeframe definitions
    return &exam_info_sptr->time_frame_definitions;
}

Succeeded
HDF5Wrapper::open(const std::string& filename)
{
    file.openFile( filename, H5F_ACC_RDONLY );

    initialise_exam_info();

    if(HDF5Wrapper::check_GE_signature(filename))
    {
        warning("CListModeDataGESigna: "
                "Probably this is GESigna, but couldn't find scan start time etc."
                "The scanner is initialised from library instread from HDF5 header.");
        is_signa = true;

        this->scanner_sptr.reset(new Scanner(Scanner::PETMR_Signa));

        return Succeeded::yes;
    }
    else
    {
        // Read from HDF5 header ...
        return initialise_scanner_from_HDF5();
    }
}

Succeeded HDF5Wrapper::initialise_scanner_from_HDF5()
{
    int num_transaxial_blocks_per_bucket = 0;
    int num_axial_blocks_per_bucket = 0;
    int axial_blocks_per_unit = 0;
    int radial_blocks_per_unit = 0;
    int axial_units_per_module = 0;
    int radial_units_per_module = 0;
    int axial_modules_per_system = 0;
    int radial_modules_per_system = 0;
    int max_num_non_arccorrected_bins = 0;
    int num_transaxial_crystals_per_block = 0;
    int num_axial_crystals_per_block = 0 ;
    float inner_ring_diameter = 0.0;
    float detector_axial_size = 0.0;
    float intrinsic_tilt = 0.0;

    int num_detector_layers = 1;
    float energy_resolution = -1.0f;
    float reference_energy = -1.0f;

    H5::DataSet str_inner_ring_diameter = file.openDataSet("/HeaderData/SystemGeometry/effectiveRingDiameter");
    H5::DataSet str_axial_blocks_per_module = file.openDataSet("/HeaderData/SystemGeometry/axialBlocksPerModule");
    H5::DataSet str_radial_blocks_per_module = file.openDataSet("/HeaderData/SystemGeometry/radialBlocksPerModule");
    H5::DataSet str_axial_blocks_per_unit = file.openDataSet("/HeaderData/SystemGeometry/axialBlocksPerUnit");
    H5::DataSet str_radial_blocks_per_unit = file.openDataSet("/HeaderData/SystemGeometry/radialBlocksPerUnit");
    H5::DataSet str_axial_units_per_module = file.openDataSet("/HeaderData/SystemGeometry/axialUnitsPerModule");
    H5::DataSet str_radial_units_per_module = file.openDataSet("/HeaderData/SystemGeometry/radialUnitsPerModule");
    H5::DataSet str_axial_modules_per_system = file.openDataSet("/HeaderData/SystemGeometry/axialModulesPerSystem");
    H5::DataSet str_radial_modules_per_system = file.openDataSet("/HeaderData/SystemGeometry/radialModulesPerSystem");
    //! \todo P.W: Find the crystal gaps and other info missing.
    H5::DataSet str_detector_axial_size = file.openDataSet("/HeaderData/SystemGeometry/detectorAxialSize");
    H5::DataSet str_intrinsic_tilt = file.openDataSet("/HeaderData/SystemGeometry/transaxial_crystal_0_offset");
    H5::DataSet str_max_number_of_non_arc_corrected_bins = file.openDataSet("/HeaderData/Sorter/dimension1Size");
    H5::DataSet str_axial_crystals_per_block = file.openDataSet("/HeaderData/SystemGeometry/axialCrystalsPerBlock");
    H5::DataSet str_radial_crystals_per_block = file.openDataSet("/HeaderData/SystemGeometry/radialCrystalsPerBlock");
    //! \todo Convert to numbers.

    str_radial_blocks_per_module.read(&num_transaxial_blocks_per_bucket, H5::PredType::NATIVE_UINT32);
    str_axial_blocks_per_module.read(&num_axial_blocks_per_bucket, H5::PredType::NATIVE_UINT32);
    str_axial_blocks_per_unit.read(&axial_blocks_per_unit, H5::PredType::NATIVE_UINT32);
    str_radial_blocks_per_unit.read(&radial_blocks_per_unit, H5::PredType::NATIVE_UINT32);
    str_axial_units_per_module.read(&axial_units_per_module, H5::PredType::NATIVE_UINT32);
    str_radial_units_per_module.read(&radial_units_per_module, H5::PredType::NATIVE_UINT32);
    str_axial_modules_per_system.read(&axial_modules_per_system, H5::PredType::NATIVE_UINT32);
    str_radial_modules_per_system.read(&radial_modules_per_system, H5::PredType::NATIVE_UINT32);
    str_inner_ring_diameter.read(&inner_ring_diameter, H5::PredType::NATIVE_FLOAT);
    str_detector_axial_size.read(&detector_axial_size, H5::PredType::NATIVE_FLOAT);
    str_intrinsic_tilt.read(&intrinsic_tilt, H5::PredType::NATIVE_FLOAT);
    str_max_number_of_non_arc_corrected_bins.read(&max_num_non_arccorrected_bins, H5::PredType::NATIVE_UINT32);
    str_radial_crystals_per_block.read(&num_transaxial_crystals_per_block, H5::PredType::NATIVE_UINT32);
    str_axial_crystals_per_block.read(&num_axial_crystals_per_block, H5::PredType::NATIVE_UINT32);

    int num_rings  = num_axial_blocks_per_bucket*num_axial_crystals_per_block*axial_modules_per_system;
    int num_detectors_per_ring = num_transaxial_blocks_per_bucket*num_transaxial_crystals_per_block*radial_modules_per_system;
    int default_num_arccorrected_bins = max_num_non_arccorrected_bins;
    float inner_ring_radius = 0.5f*inner_ring_diameter;
    float average_depth_of_interaction = 0.5f; // Assuming this to be constant. Although this will change depending on scanner.
    float ring_spacing = detector_axial_size/num_rings;

    //! \todo : bin_size
    float bin_size = max_num_non_arccorrected_bins/inner_ring_radius;
    int num_axial_crystals_per_singles_unit =1;
    int num_transaxial_crystals_per_singles_unit =1;

    //PW Not sure what to put for scanner here.
    this->scanner_sptr.reset(new Scanner(Scanner::User_defined_scanner));
    scanner_sptr->set_num_rings(num_rings);
    scanner_sptr->set_max_num_non_arccorrected_bins(max_num_non_arccorrected_bins);
    scanner_sptr->set_default_num_arccorrected_bins(default_num_arccorrected_bins);
    scanner_sptr->set_num_detectors_per_ring(num_detectors_per_ring);
    scanner_sptr->set_inner_ring_radius(inner_ring_radius);
    scanner_sptr->set_average_depth_of_interaction(average_depth_of_interaction);
    scanner_sptr->set_ring_spacing(ring_spacing);
    scanner_sptr->set_default_bin_size(bin_size);
    scanner_sptr->set_default_intrinsic_tilt(intrinsic_tilt);
    scanner_sptr->set_num_axial_blocks_per_bucket(num_axial_blocks_per_bucket);
    scanner_sptr->set_num_transaxial_blocks_per_bucket(num_transaxial_blocks_per_bucket);
    scanner_sptr->set_ring_spacing(ring_spacing);
    scanner_sptr->set_num_axial_crystals_per_block(num_axial_crystals_per_block);
    scanner_sptr->set_num_transaxial_crystals_per_block(num_transaxial_crystals_per_block);
    scanner_sptr->set_num_axial_crystals_per_singles_unit(num_axial_crystals_per_singles_unit);
    scanner_sptr->set_num_transaxial_crystals_per_singles_unit(num_transaxial_crystals_per_singles_unit);
    scanner_sptr->set_num_detector_layers(num_detector_layers);
    scanner_sptr->set_energy_resolution(energy_resolution);
    scanner_sptr->set_reference_energy(reference_energy);


    return Succeeded::yes;
}

Succeeded HDF5Wrapper::initialise_exam_info()
{
    this->exam_info_sptr.reset(new ExamInfo());

    // PW Get the high and low energy threshold values from HDF5 header.
    int low_energy_thres = 0;
    int high_energy_thres = 0;

    H5::DataSet str_low_energy_thres = file.openDataSet("/HeaderData/AcqParameters/EDCATParameters/lower_energy_limit");
    H5::DataSet str_high_energy_thres = file.openDataSet("/HeaderData/AcqParameters/EDCATParameters/upper_energy_limit");

    str_low_energy_thres.read(&low_energy_thres, H5::PredType::NATIVE_UINT32);
    str_high_energy_thres.read(&high_energy_thres, H5::PredType::NATIVE_UINT32);

    float low_energy_thres_f = static_cast<float>(low_energy_thres);
    float high_energy_thres_f = static_cast<float>(high_energy_thres);

    // PW Set these values in exam_info_sptr.
    exam_info_sptr->set_high_energy_thres(high_energy_thres_f);
    exam_info_sptr->set_low_energy_thres(low_energy_thres_f);

    //! \todo convert time slices to timeFrameDefinitions
    //NE Copied from SignesRatesFromGEHDF5:
    //PW Get the total number of time slices from the HDF5 file format.

    unsigned int num_time_slices = 0;
    H5::DataSet timeframe_dataspace = file.openDataSet("/HeaderData/SinglesHeader/numValidSamples");
    timeframe_dataspace.read(&num_time_slices, H5::PredType::NATIVE_UINT32);
    std::vector<std::pair<double, double> >tf(num_time_slices);

    for (int i = 0; i < num_time_slices; ++i)
    {
        tf[i].first = i;
        tf[i].second = i + 1;
    }

    TimeFrameDefinitions tm(tf);
    exam_info_sptr->set_time_frame_definitions(tm);

    return Succeeded::yes;
}

Succeeded HDF5Wrapper::initialise_listmode_data(const std::string &path)
{
    if(path.size() == 0)
    {
        if(is_signa)
        {
            m_address = "/ListData/listData";
            //! \todo Get these numbers from the HDF5 file
            {
            m_size_of_record_signature = 6;
            m_max_size_of_record = 16;
            }
        }
        else
            return Succeeded::no;
    }
    else
        m_address = path;

    m_dataset_sptr.reset(new H5::DataSet(file.openDataSet(m_address)));

    m_dataspace = m_dataset_sptr->getSpace();
    int dataset_list_Ndims = m_dataspace.getSimpleExtentNdims();

    hsize_t dims_out[dataset_list_Ndims];
    m_dataspace.getSimpleExtentDims( dims_out, NULL);
    m_list_size=dims_out[0];
    const long long unsigned int tmp_size_of_record_signature = m_size_of_record_signature;
    m_memspace_ptr = new H5::DataSpace( dataset_list_Ndims,
                            &tmp_size_of_record_signature);


    return Succeeded::yes;
}

Succeeded HDF5Wrapper::initialise_singles_data(const std::string &path)
{
    if(path.size() == 0)
    {
        if(is_signa)
        {
            m_address = "/Singles/CrystalSingles/sample";
            //! \todo Get these numbers from the HDF5 file
            {
                m_NX_SUB = 45;    // hyperslab dimensions
                m_NY_SUB = 448;
                m_NX = 45;        // output buffer dimensions
                m_NY = 448;
            }
        }
        else
            return Succeeded::no;
    }
    else
        m_address = path;

    return Succeeded::yes;
}


Succeeded HDF5Wrapper::get_from_dataspace(std::streampos& current_offset, shared_ptr<char>& data_sptr)
{

    hsize_t pos = static_cast<hsize_t>(current_offset);
    m_dataspace.selectHyperslab( H5S_SELECT_SET, &m_size_of_record_signature, &pos );
    m_dataset_sptr->read( data_sptr.get(), H5::PredType::STD_U8LE, *m_memspace_ptr, m_dataspace );
    current_offset += static_cast<std::streampos>(m_size_of_record_signature);

    //  // TODO error checking
    return Succeeded::yes;
}

Succeeded HDF5Wrapper::get_dataspace(const unsigned int current_id,
                                     Array<1, unsigned int>& data_ptr)
{
    std::ostringstream datasetname;
    datasetname << m_address << current_id;
    m_dataset_sptr.reset(new H5::DataSet(file.openDataSet(datasetname.str())));
    m_dataset_sptr->read( data_ptr.get_data_ptr(), H5::PredType::NATIVE_UINT32);
    data_ptr.release_data_ptr();

    //  // TODO error checking
    return Succeeded::yes;
}

Succeeded HDF5Wrapper::get_dataspace(const unsigned int current_id,
                                     shared_ptr<Array<2, unsigned int> >& data_sptr)
{
    std::ostringstream datasetname;
    datasetname << m_address << current_id;
    m_dataset_sptr.reset(new H5::DataSet(file.openDataSet(datasetname.str())));
    m_dataset_sptr->read( (*data_sptr)[current_id].get_data_ptr(), H5::PredType::NATIVE_UINT32);
    (*data_sptr)[current_id].release_data_ptr();

    //  // TODO error checking
    return Succeeded::yes;
}

//stir::Array<2, float>* data_sptr;
//shared_ptr<char> HDF5Wrapper::get_next_viewgram()
//{

//}

//stir::Array<2, float>* data_sptr;
//shared_ptr<char> HDF5Wrapper::get_next_sinogram()
//{

//}

//stir::Array<3, float>* data_sptr;
//shared_ptr<char> HDF5Wrapper::get_next_segment_by_sinogram()
//{

//}

//stir::Array<3, float>* data_sptr;
//shared_ptr<char> HDF5Wrapper::get_next_segment_by_viewgram()
//{

//}

// initialise_singles
// Can be used for normalisation, too.
// Can be used for nonTOF sinograms.
//Succeeded HDF5Wrapper::initialise_list_2D_arrays(const std::string &path)
//{
//    if(path.size() == 0)
//    {
//        if(is_signa)
//        {
//            m_listmode_address = "/ListData/listData";
//        }
//        else
//            return Succeeded::no;
//    }
//    else
//        m_listmode_address = path;

//    dataset_list_sptr.reset(new H5::DataSet(file.openDataSet(m_listmode_address)));

//    H5::DataSpace dataspace = dataset_list_sptr->getSpace();
//    dataset_list_Ndims = dataspace.getSimpleExtentNdims() ;


//    return Succeeded::yes;
//}



END_NAMESPACE_STIR

